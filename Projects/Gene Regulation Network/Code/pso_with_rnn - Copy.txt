# -*- coding: utf-8 -*-
"""PSO with RNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PILE18IVeboodmH2piGpXKxY14K73IBA
"""

import numpy as np
import random
import math
import pandas as pd

data = pd.read_csv('Exp_1.csv', sep=',')

class Particle:
  def __init__(self,position,velocity,fitness):
    self.position = position
    self.velocity  = velocity
    self.local_best_position = position.copy()
    self.fitness = fitness
  def update_local_best(self,local_best_position_new):
    self.local_best_position = local_best_position_new.copy()
  def update_fitness(self,fitness):
    self.fitness = fitness

# Define the modified fitness function to calculate MSE
def fitness_function(T,array1,array2):
    # Compute the squared error for each element
    squared_error = np.mean((array1-array2) ** 2)
    return squared_error

def sigmoid(x):
        return 1 / (1 + np.exp(-x))

def  RNN(data,gene_index,position):
  T = len(data)
  gene_predicted = []
  delta_t = 6
  tau = position[9]
  gene_predicted.append(data.iloc[0].values[gene_index+1])
  for t in range(1, len(data)):
      gene_tp = data.iloc[t].values
      gene_tp_1 = gene_tp[1:]
      weight_mul =  position[:8] * gene_tp_1
      s = sigmoid(sum(weight_mul)+position[8])
      Rnn = (delta_t/tau) * s + (1-(delta_t/tau)) * gene_tp_1[gene_index]
      gene_predicted.append(Rnn)
  gene_actual_data = data.iloc[:, gene_index+1]
  gene_actual = gene_actual_data.to_numpy()
#  fitness = (1/T)  * sum((column_array - gene_predicted)**2)
  fitness = fitness_function(T,gene_actual,np.array(gene_predicted))
  return fitness

def PSO(num_gene,num_particle,max_iteration,max_inertia,min_inertia,accel_factor):
    # Store all gbest for all gene
    gene_gbest_position =[]
    for gene in range(num_gene):
      np.random.seed(7 + gene)
      particles = []    # Store all the particles
      swarm_global_best_position = None  # Initialization of global best
      swarm_best_fitness = float('inf')  # Initialization of fitness
      for population in range(num_particle):
        # Initialize position, velocity, and fitness for each particle
        position = np.random.uniform(-1,1,num_gene+2)
        velocity = np.zeros(num_gene+2)
        fitness = RNN(data,gene,position)
        #print(f'for gene {gene} for population {population} initial fitness is {fitness} \n')
        #print(f'predicted value for popution{ population} is {predicted}')
        # Update global best according
        if fitness < swarm_best_fitness:
            swarm_best_fitness = fitness
            swarm_global_best_position = position.copy()
        particles.append(Particle(position,velocity,fitness))
      for itr in range(max_iteration-1):
        w = max_inertia - (max_inertia - min_inertia) * itr / max_iteration
        r1 = random.random()
        r2 = random.random()
        for index,particle in enumerate(particles):
          #Update Velocity
          particle.velocity = (w * particle.velocity +
                                 accel_factor * r1 * (particle.local_best_position - particle.position) +
                                 accel_factor * r2 * (swarm_global_best_position - particle.position))

            # Update position
          particle.position += particle.velocity
          #If particle value exceed the range then reinitialize
          if np.any(np.abs(particle.position) > 1):
              particle.position = np.random.uniform(-1, 1, num_gene + 2)
              velocity = np.zeros(num_gene+2)
          if(particle.position[9] == 0):
             particle.position[9] = np.random(-1,1)
          #Calculate fitness using RNN
          fitness = RNN(data,gene,particle.position)
          if fitness < particle.fitness:
            particle.update_fitness(fitness)
            particle.update_local_best(particle.position)
          if fitness < swarm_best_fitness:
            swarm_best_fitness = fitness
            swarm_global_best_position = particle.position.copy()
            print(f"population best update for gene : {gene} iteration {itr} population: {index}.\n New global best is : {swarm_global_best_position}\n")
      gene_gbest_position.append(swarm_global_best_position);
    gbest_matrix = np.array(gene_gbest_position)
    # Extract the first N elements from each row to get an N x N matrix
    fij_matrix = gbest_matrix[:, :num_gene]
    return fij_matrix

if __name__ == '__main__':
  num_gene = 8
  num_regulator = 4
  num_particle = math.comb(num_gene,num_regulator)
#  num_particle = 3
  max_iteration = 1000
  max_inertia = 0.9
  min_inertia = 0.4
  accel_factor = 2  # c1 = c2 = 2
  for cur in range(5):
    result_matrix = PSO(num_gene, num_particle, max_iteration, max_inertia, min_inertia, accel_factor)
    csv_filename = "result_matrix"+"_"+str(max_iteration)+"_"+str(cur)+".csv"
    pd.DataFrame(result_matrix).to_csv(csv_filename, index=False)