# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1unwTRma0V_KZRlIpBhesYTefiYaPVmzh
"""

import pandas as pd


dataset = pd.read_csv('Iris.csv')

data = dataset.iloc[:,:-1]
data

shuffled_df = data.iloc[:,1:].sample(frac=1, random_state=42).reset_index(drop=True)

shuffled_df

import numpy as np

np.random.seed(43)
values =np.random.randint(0,149,3)
values

# Select the columns from shuffled_df based on the generated indices
new_dataset = shuffled_df.iloc[values,:]
print(new_dataset)

distance_matrix = np.zeros((150,3))
for i in range(0,150):
      for j in range(0,3):
              distance_matrix[i][j] =  np.sqrt(np.sum((shuffled_df.iloc[i, :] - new_dataset.iloc[j, :])**2))
distance_matrix

group1 = []
group2 = []
group3 = []
print(len(distance_matrix))
for i in range(len(distance_matrix)):
    min_index = np.argmin(distance_matrix[i])  # Find the index of the minimum value in the row
    print(distance_matrix[i][min_index])   # Set the minimum value's position to 0
#    print(min_index)
    if min_index == 0:
        group1.append(i)
    elif min_index == 1:
        group2.append(i)
    else:
        group3.append(i)
print(group1)
print(group2)
print(group3)
# Extract data for each group using `.iloc`
group1_data = shuffled_df.iloc[group1, :]
group2_data = shuffled_df.iloc[group2, :]
group3_data = shuffled_df.iloc[group3, :]

# Calculate centroids
group1_centroid = group1_data.mean().to_numpy() if not group1_data.empty else None
group2_centroid = group2_data.mean().to_numpy() if not group2_data.empty else None
group3_centroid = group3_data.mean().to_numpy() if not group3_data.empty else None

# Print centroids
print("Group 1 Centroid:", group1_centroid)
print("Group 2 Centroid:", group2_centroid)
print("Group 3 Centroid:", group3_centroid)


# Combine centroids into one array
centroids = np.vstack([group1_centroid, group2_centroid, group3_centroid])

# Print combined centroids
print("Centroids Array:")
print(centroids)

distance_matrix = np.zeros((150,3))
for i in range(0,150):
      for j in range(0,3):
             distance_matrix[i][j] = np.sqrt(np.sum((shuffled_df.iloc[i, :].to_numpy() - centroids[j, :])**2))
distance_matrix

# Initialize groups as empty NumPy arrays
group4 = np.array([], dtype=int)  # Define the dtype as int to store indices
group5 = np.array([], dtype=int)
group6 = np.array([], dtype=int)

print(len(distance_matrix))

# Assign each index to a group based on the minimum distance in each row
for i in range(len(distance_matrix)):
    min_index = np.argmin(distance_matrix[i])  # Find the index of the minimum value in the row
    print(distance_matrix[i][min_index])   # Print the minimum value
    if min_index == 0:
        group4 = np.append(group4, i)  # Add index to group4
    elif min_index == 1:
        group5 = np.append(group5, i)  # Add index to group5
    else:
        group6 = np.append(group6, i)  # Add index to group6

# Now, group4, group5, group6 are NumPy arrays with the assigned indices
print("Group 4 indices:", group4)
print("Group 5 indices:", group5)
print("Group 6 indices:", group6)
group1= np.array(group1)
group2 = np.array(group2)
group3 = np.array(group3)
# Example operation (make sure you have group1, group2, group3 defined as NumPy arrays)
try:
  if(group1.shape == group3.shape):
    print(group4 - group1)  # Assuming group1 is a NumPy array
  if(group2.shape == group3.shape):
    print(group5 - group2)  # Assuming group2 is a NumPy array
  if(group3.shape == group6.shape):
    print(group6 - group3)  # Assuming group3 is a NumPy array

    if(group1.shape == group3.shape and group2.shape == group3.shape and group3.shape == group6.shape):
      print("All arrays have the same shape.")
    else:
      print("Arrays have different shapes.")
except NameError:
    print("group1, group2, or group3 is not defined.")

# Define the arrays
db1 = np.array([1, 1, 1, 1])  # Shape (4,)
db2 = np.array([[2, 2, 2, 2],  # Shape (3, 4)
                [3, 3, 3, 3],
                [4, 4, 4, 4]])

# Calculate Euclidean distance for each row in db2 from db1
db3 = np.sqrt(np.sum((db1 - db2) ** 2, axis=1))

# Print the results
print("Distances:", db3)

import numpy as np

db4 = np.array([[1, 2, 3], [3, 4, 2], [2, 1, 4]])

# Iterate through each row
for i in range(len(db4)):
    min_index = np.argmin(db4[i])  # Find the index of the minimum value in the row
    db4[i] = 1  # Set all values to 1
    db4[i][min_index] = 0  # Set the minimum value's position to 0
    print(min_index)

print(db4)
db4