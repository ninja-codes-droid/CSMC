# -*- coding: utf-8 -*-
"""Gini Index.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wF5iZQx6c48a9QzrmRWmOOZJV993UixK
"""

import pandas as pd

golf_play = pd.read_csv('GolfPlay.csv')
golf_play

sunny_df = golf_play[golf_play['OutLook'] == 'Sunny']
sunny_df

# Group by 'Outlook' and count the Yes/No decisions in the 'Play' column
summary = golf_play.groupby('OutLook')['Decision'].value_counts().unstack(fill_value=0)

# Create a new DataFrame with the counts for 'Yes' and 'No' decisions
summary_df = pd.DataFrame({
    'Outlook': summary.index,
    'No. of Yes': summary.get('Yes', 0),  # Count of Yes decisions
    'No. of No': summary.get('No', 0),    # Count of No decisions
})

# Add a column for the total of Yes and No decisions
summary_df['Total'] = summary_df['No. of Yes'] + summary_df['No. of No']

# Reset the index to have a clean DataFrame
summary_df.reset_index(drop=True, inplace=True)
summary_df

outlook_array = summary_df['Outlook'].values
squared_fractions = []
giniIndex = 0
for index, row in summary_df.iterrows():
  squared_fraction_1 = (summary_df.loc[index, 'No. of Yes'] / summary_df.loc[index, 'Total']) ** 2
  squared_fraction_2 = (summary_df.loc[index, 'No. of No'] / summary_df.loc[index, 'Total']) ** 2
  squared_fraction = 1 - squared_fraction_1 - squared_fraction_2
  giniIndex += squared_fraction * (summary_df.loc[index, 'Total'] / summary_df['Total'].sum())
  print(outlook_array[index],squared_fraction)
print("GiniIndex:",giniIndex)

outlook_array = golf_play['OutLook'].unique()
squared_fractions = []
giniIndex = 0

for outlook in outlook_array:
  temp = golf_play[golf_play['OutLook'] == outlook]
  total = len(temp)
  yes = len(temp[temp['Decision'] == 'Yes'])
  no = len(temp[temp['Decision'] == 'No'])

  squared_fraction_1 = (yes / total) ** 2
  squared_fraction_2 = (no / total) ** 2
  squared_fraction = 1 - squared_fraction_1 - squared_fraction_2

  giniIndex += squared_fraction * (total / len(golf_play))
  print(outlook,squared_fraction)

print("GiniIndex:",giniIndex)

golf_play.columns

giniIndexArray = []
for i in golf_play.columns[:4]:
  print(golf_play[i].unique())
  column_array = golf_play[i].unique()
  squared_fractions = []
  giniIndex = 0

  for column in column_array:
    temp = golf_play[golf_play[i] == column]
    total = len(temp)
    yes = len(temp[temp['Decision'] == 'Yes'])
    no = len(temp[temp['Decision'] == 'No'])

    squared_fraction_1 = (yes / total) ** 2
    squared_fraction_2 = (no / total) ** 2
    squared_fraction = 1 - squared_fraction_1 - squared_fraction_2

    giniIndex += squared_fraction * (total / len(golf_play))
    print(column,squared_fraction)

  print(i,"GiniIndex:",giniIndex)
  giniIndexArray.append(giniIndex)

minimum = min(giniIndexArray)
index = giniIndexArray.index(minimum)
print(golf_play.columns[index],minimum)

split_datasets = {}
for value in golf_play['OutLook'].unique():
  split_datasets[value] = golf_play[golf_play['OutLook'] == value]

# Access the split datasets
sunny_df = split_datasets['Sunny']
rainy_df = split_datasets['Rain']
overcast_df = split_datasets['Overcast']
sunny_df

def calculate_gini_index(data, target_column):
  gini_index_array = []
  for column in data.columns:
    if column == target_column:
      continue
    column_array = data[column].unique()
    gini_index = 0
    for value in column_array:
      subset = data[data[column] == value]
      total = len(subset)
      if total == 0:
        continue
      yes = len(subset[subset[target_column] == 'Yes'])
      no = len(subset[subset[target_column] == 'No'])
      squared_fraction_1 = (yes / total) ** 2
      squared_fraction_2 = (no / total) ** 2
      squared_fraction = 1 - squared_fraction_1 - squared_fraction_2
      gini_index += squared_fraction * (total / len(data))
    gini_index_array.append(gini_index)
  return gini_index_array

def build_decision_tree(data, target_column, features):
  if len(data[target_column].unique()) == 1:
    return data[target_column].iloc[0]
  if len(features) == 0:
    return data[target_column].value_counts().idxmax()
  gini_indices = calculate_gini_index(data, target_column)
  if not gini_indices:
    return data[target_column].value_counts().idxmax()
  best_feature_index = gini_indices.index(min(gini_indices))
  if best_feature_index >= len(features):
    return data[target_column].value_counts().idxmax()
  best_feature = features[best_feature_index]
  tree = {best_feature: {}}
  features = [f for f in features if f != best_feature]
  for value in data[best_feature].unique():
    subset = data[data[best_feature] == value]
    subtree = build_decision_tree(subset, target_column, features)
    tree[best_feature][value] = subtree
  return tree

tree = build_decision_tree(golf_play, 'Decision', golf_play.columns[:-1])
print(tree)